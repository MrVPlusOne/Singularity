## Graph Components

We implement a generic graph data structure in Singularity. A graph of type `T` consists of an integer `n` recording the number of nodes and a list of edges, each containing an edge value of type `T`.

All graph-related components in our standard component set have a return type of `Graph[T]` and are listed below:

Name              | Description
------------------|-------------
`emptyGraph()`    |  create an empty graph
`addNode(g)`      |  add a new node to the graph `g`
`addEdge(g, v)`   |  add a new edge with two new endpoints and edge value `v` to the graph `g`
`growEdge(g, v, i)` |  add a new edge with one endpoint being an existing node `i`
`growSelfLoop(g, v, i)` |  add a new self loop to an existing node `i`
`bridgeEdge(g, v, i1, i2)` |  add an edge between two existing vertices `i1`, `i2`
`deleteEdge(g, i)`  |  delete an existing edge indexed `i` from graph `g`
`mergeGraph(g1, g2)` |  merge two graphs into one graph
`updateEdgeValue(g, v, i)`  |  update the `i`th edge's value in graph `g`
`addCompleteNode(g, v)`  |  add a new node, then connect it to all existing nodes with edge value `v`


## The JGraphT Example

Using these simple but expressive components, we were able to find the complexity vulnerability from one of the **maximal flow** implementation from JGraphT. We translated the input pattern Singularity found into self-contained Java code and reported it in [this bug report](https://github.com/jgrapht/jgrapht/issues/461).

The pattern we found corresponds to a RCG with 2 internal states, as shown below:

```
seed for g: addNode(emptyGraph())
seed for i: 0

updater for i: plus(i,2)
updater for g: growEdge(bridegeEdge(growEdge(g, 3, 0), 4, inc(i), i), 0, 0)

output: g
```

The graphs generated by this RCG look like this:

<img width='400' src="https://github.com/MrVPlusOne/MrVPlusOne.github.io/blob/master/img/Singularity_JGraphT.png?raw=true">

The RCG adds three new edges to the graph in each iteration. For example, suppose node 1~7 consist the current graph, in the next iteration, the updater first adds the outgoing edge 1->8 with edge weight 3; then, it adds the backward edge 8->1 with weight 4; finally, it creates the purple edge 1->9 with weight 0.

To trigger the n^5 complexity, the structure of the graph must be correct -- both those double edges (green ones) and single edges (purple one) are needed. In addition, the purple edge must have a weight of 0. The outgoing green edge can have any positive weight `w`, but the backward green edge's weight must be `w+1`.


## The Guava Example



```
type of s0, s1: Int
type of s2, s3: Pair[Int]
type of s4: List[Pair[Int]]

seed for s0: 244
seed for s1: 475
seed for s2: (271, 212)
seed for s3: (239, 26)
seed for s4: []

updater for s0: 170
updater for s1: plus(plus(bitOr(times(times(99, 302), 486), 475), 142), dec(s1))
updater for s2: mkPair(pair2(s2), bitShift(s1, 353))
updater for s3: s2
updater for s4: append(s4,s2)

output: s4
```

