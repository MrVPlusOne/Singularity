package singularity

import org.apache.commons.math3.analysis.ParametricUnivariateFunction
import org.apache.commons.math3.exception.ConvergenceException
import singularity.EvolutionRepresentation.MemoryUsage

import scala.collection.mutable
import scala.util.Random


object PerformanceEvaluation {
  case class EvaluationResult(value: Double, extraData: AnyRef)
}

case class PerformanceEvalResult(perf: Double, info: String)

/** Defines how to evaluate the performance of an input pattern (as a series of inputs). As shown in
  * the Singularity paper, using [[singularity.SimplePerformanceEvaluation]] with a large enough
  * `sizeOfInterest` gives an ideal measurement model. */
trait PerformanceEvaluation {
  def resourceUsage: IS[EValue] => Double
  def sizeF: IS[EValue] => Int
  def nonsenseFitness: Double
  def breakingMemoryUsage: Long

  def evaluateAPattern(inputStream: Stream[(MemoryUsage, IS[EValue])]): PerformanceEvalResult
}

object ExtrapolatePerformanceEvaluation{
  sealed trait EvaluationResult{
    def value: Double
  }

  case class ExtrapolatedResult(value: Double, dataPoints: Seq[(Int, Double)]) extends EvaluationResult
  case class MaxSoFarResult(value: Double) extends EvaluationResult

}

/** Evaluate the performance of an input pattern using the maximal resource usage of the last several inputs in the input pattern. As shown in the Singularity paper, using [[singularity.SimplePerformanceEvaluation]] with a large enough
  * `sizeOfInterest` gives an ideal measurement model.
  * @param sizeOfInterest the max size of inputs used for evaluation
  * @param evaluationTrials the "window size" specifying how many inputs should be used. When set to 1, only the last
  *                         input whose size does not exceed [[sizeOfInterest]] will be used.
  * */
class SimplePerformanceEvaluation(sizeOfInterest: Int, evaluationTrials: Int, val resourceUsage: (IS[EValue]) => Double, val sizeF: (IS[EValue]) => Int, val breakingMemoryUsage: Long, val nonsenseFitness: Double) extends PerformanceEvaluation {


  def evaluateAPattern(inputStream: Stream[(MemoryUsage, IS[EValue])]): PerformanceEvalResult = {
    var lastSize = Int.MinValue
    val pointsToTry = inputStream.takeWhile { case (usage, input) =>
      val inputSize = sizeF(input)
      if (inputSize <= lastSize || usage.amount > breakingMemoryUsage)
        return PerformanceEvalResult(nonsenseFitness, "inputSize <= lastSize || usage.amount > breakingMemoryUsage")
      lastSize = inputSize
      sizeF(input) <= sizeOfInterest
    }.takeRight(evaluationTrials)

    if (pointsToTry.isEmpty)
      PerformanceEvalResult(nonsenseFitness, "pointsToTry.isEmpty")
    else
      PerformanceEvalResult(pointsToTry.map(_._2).map(resourceUsage).max, "Simple Eval")
  }
}

/** Evaluate the performance of an input pattern using curve fitting. Can become very unstable when data points are
  * generated by too small inputs. */
object FittingPerformanceEvaluation {

  trait FittingModel{
    def fitModel(xyPoints: IS[(Double, Double)], xRange: (Double, Double)): (IS[Double], Double, String)
  }

  case class PowerLawFitter(maxIter: Int, gofPenaltyBase: Double = 100.0) extends FittingModel{

    def fitModel(xyPoints: IS[(Double, Double)], xRange: (Double, Double)): (IS[Double], Double, String) = {
      import collection.JavaConverters._
      import org.apache.commons.math3.fitting.{SimpleCurveFitter, WeightedObservedPoints}

      val xRangeSize = xRange._2 - xRange._1
      val nPoints = xyPoints.length
      val weights = xyPoints.indices.map{i =>
        val d1 = if(i>0) xyPoints(i)._1 - xyPoints(i-1)._1 else 0.0
        val d2 = if(i+1<nPoints) xyPoints(i+1)._1 - xyPoints(i)._1 else 0.0
        (d1+d2)/xRangeSize
      }

      val scale = math.max(xyPoints.map(p => math.abs(p._2)).max, 1.0)
      val obPoints = new WeightedObservedPoints()
      xyPoints.indices.foreach{i =>
        obPoints.add(weights(i), xyPoints(i)._1, xyPoints(i)._2/scale)
      }

      val observations = obPoints.toList
      val Array(a1,b,c1) = ModifiedCurveFitter.create(PowerLawFunction, Array(10.0, 2.0, 0.0)).withMaxIterations(maxIter).fit(observations)
      val (a,c) = (a1*scale, c1*scale)
      def f(x: Double) = a * math.pow(x, b) + c

//      val weights = new Array[Double](nPoints)
      val xs = new Array[Double](nPoints)
      val ys = new Array[Double](nPoints)
      observations.asScala.zipWithIndex.foreach{
        case (wp, i) =>
          xs(i) = wp.getX
          ys(i) = wp.getY * scale
      }
      val rs = SimpleMath.rSquared(ys, xs.map(f), weights)
      val beta: Double = {
        assert(0.0 <= rs && rs <= 1.0, s"r squared should be in [0,1], but actually in $rs")
        gofPenaltyBase * math.pow(gofPenaltyBase, -1.0 / (rs * rs))
      }

      (IS(a,b,c), beta, s"$a * x ^ $b + $c, rSquared = $rs, beta = $beta, data = {${xs.mkString("{",",","}")},${ys.mkString("{",",","}")}}")
    }
  }

  object PowerLawFunction extends ParametricUnivariateFunction{
    def gradient(x: Double, abc: Double*): Array[Double] = {
      val Seq(a,b,c) = abc
      val xb = math.pow(x, b)
      Array(xb, a * xb * math.log(x),1.0)
    }

    def value(x: Double, abc: Double*): Double = {
      val Seq(a,b,c) = abc
      a * math.pow(x, b) + c
    }
  }

  def pModel(model: IS[Double], gamma: Double, size: Int): Double = {
    val IS(a,p,c) = model
    p * gamma
  }

  def hybridModel(scaleFactor: Double)(model: IS[Double], gamma: Double, size: Int): Double = {
    val IS(a,p,c) = model
    (a * math.pow(scaleFactor * SimpleMath.square(gamma) * size, p) + c) * gamma
  }
}

/** Evaluate the performance of an input pattern using curve fitting. Can become very unstable when data points are
  * generated by too small inputs. (i.e. when [[sizeOfInterest]] is not large enough) */
class FittingPerformanceEvaluation(sizeOfInterest: Int, val resourceUsage: (IS[EValue]) => Double,
                                   val sizeF: (IS[EValue]) => Int,
                                   val breakingMemoryUsage: Long,
                                   val nonsenseFitness: Double,
                                   val minPointsToUse: Int,
                                   val maxPointsToUse: Int,
                                   val fitter: FittingPerformanceEvaluation.FittingModel,
                                   val modelToScore: (IS[Double], Double, Int) => Double,
                                   extraSizeF: Option[IS[EValue] => Double] = None
                                   ) extends PerformanceEvaluation {

  def usableInputs(inputStream: Stream[(MemoryUsage, IS[EValue])], extraSizeF: IS[EValue] => Double): Option[IS[(Double, IS[EValue])]] = {
    var lastSize = Int.MinValue
    val xyPoints = mutable.ListBuffer[(Double, IS[EValue])]()
    inputStream.foreach{ case (usage, input) =>
      val inputSize = sizeF(input)
      if (inputSize <= lastSize || usage.amount > breakingMemoryUsage)
        return None
      lastSize = inputSize
      val shouldContinue = sizeF(input) <= sizeOfInterest
      if(!shouldContinue)
        return Some(xyPoints.toIndexedSeq)
      xyPoints.append(extraSizeF(input) -> input)
    }
    Some(xyPoints.toIndexedSeq)
  }


  def evaluateAPattern(inputStream: Stream[(MemoryUsage, IS[EValue])]): PerformanceEvalResult = {

    usableInputs(inputStream, extraSizeF.getOrElse(x => sizeF(x).toDouble)) match {
      case Some(pts) =>
        val points = pts.filter(p => p._1 > 0)
        if (points.length < minPointsToUse)
          return PerformanceEvalResult(nonsenseFitness, s"[points.length < minPointsToUse]: ${pts.take(10)}")
        val xyPoints = {
          val ps = SimpleMath.randomSelectFrom(points, maxPointsToUse, new Random(1)).map{
            case (x, input) => x.toDouble -> resourceUsage(input)
          }
          ps.map(_._1) zip SimpleMath.maxSmooth(ps.map(_._2))
        }
        val xRange = (xyPoints.head._1, sizeOfInterest.toDouble)
        try {
          val (model, beta, info) = fitter.fitModel(xyPoints, xRange)
          PerformanceEvalResult(modelToScore(model, beta, sizeOfInterest), info)
        } catch {
          case cE: ConvergenceException =>
            System.err.println{"ConvergenceException when try to fit a curve during resource usage evaluation."}
            System.err.println{s"xyPoints: $xyPoints"}
            System.err.println{s"xRange: $xRange"}
            throw cE
        }
      case _ => PerformanceEvalResult(nonsenseFitness, "usableInputs is None")
    }
  }
}


